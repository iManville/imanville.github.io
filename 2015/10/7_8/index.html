<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>术语表 | Git Community Book 中文版</title>
<<<<<<< HEAD
  <meta name="author" content="http://gitbook.liuhui998.com/">
=======
  <meta name="author" content="http://gitbook.liuhui998.com">
>>>>>>> b3482d662731bcd8b034f064a94793b0e4183171
  
  <meta name="description" content="术语表我们把在Git里常用的一些名词做了解释列在这里。这些名词(terms)全部来自Git Glossary。
alternate object database

  Via the alternates mechanism, a repository    can inherit part of">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="术语表"/>
  <meta property="og:site_name" content="Git Community Book 中文版"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="Git Community Book 中文版" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">Git Community Book 中文版</a><span class="split"></span><span class="title">术语表</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2015-10-21</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h2 id="术语表">术语表</h2><p>我们把在Git里常用的一些名词做了解释列在这里。这些名词(terms)全部来自<a href="http://www.kernel.org/pub/software/scm/git/docs/gitglossary.html" target="_blank" rel="external">Git Glossary</a>。</p>
<p><em>alternate object database</em></p>
<blockquote>
<p>  Via the alternates mechanism, a repository<br>    can inherit part of its object database<br>    from another object database, which is called “alternate”. </p>
</blockquote>
<p><em>bare repository</em></p>
<blockquote>
<p>  A bare repository is normally an appropriately<br>    named directory with a <code>.git</code> suffix that does not<br>    have a locally checked-out copy of any of the files under<br>    revision control. That is, all of the <code>git</code><br>    administrative and control files that would normally be present in the<br>    hidden <code>.git</code> sub-directory are directly present in the<br>    <code>repository.git</code> directory instead,<br>    and no other files are present and checked out. Usually publishers of<br>    public repositories make bare repositories available.</p>
</blockquote>
<p><em>祼仓库</em></p>
<p>&gt;<br>    A bare repository is normally an appropriately<br>    named directory with a <code>.git</code> suffix that does not<br>    have a locally checked-out copy of any of the files under<br>    revision control. That is, all of the <code>git</code><br>    administrative and control files that would normally be present in the<br>    hidden <code>.git</code> sub-directory are directly present in the<br>    <code>repository.git</code> directory instead,<br>    and no other files are present and checked out. Usually publishers of<br>    public repositories make bare repositories available.</p>
<p><em>blob object（二进制对象）</em></p>
<blockquote>
<p>   没有类型的数据对象。例如：一个文件的内容。</p>
</blockquote>
<p><em>branch</em></p>
<blockquote>
<p>  A “branch” is an active line of development.  The most recent<br>    commit on a branch is referred to as the tip of<br>    that branch.  The tip of the branch is referenced by a branch<br>    head, which moves forward as additional development<br>    is done on the branch.  A single git<br>    repository can track an arbitrary number of<br>    branches, but your working tree is<br>    associated with just one of them (the “current” or “checked out”<br>    branch), and HEAD points to that branch.</p>
</blockquote>
<p><em>分支</em><br>&gt;<br>    一个“分支”是开发过程中的(active line)。。。。</p>
<p><em>cache（缓存）</em></p>
<blockquote>
<p>  索引(index)的旧称(obsolete).</p>
</blockquote>
<p><em>chain（链表）</em></p>
<blockquote>
<p>  一串对象，其中每个对象都有指向其后继对象的引用(reference to its successor)。例如：一个提交(commit)的后继对象就是它的父对象。</p>
</blockquote>
<p><em>changeset（修改集）</em></p>
<blockquote>
<p>  BitKeeper/cvsps 里对于提交(commit)的说法。但是 git 只存储快照(states)，不存储修改；所以这个词用在 git 里有点不大合适。</p>
</blockquote>
<p><em>checkout（签出）</em><br>&gt;<br>    用对象仓库(object database)里的一个树对象(tree object)更新当前整个工作树(worktree)，或者一个二进制对象(blob object)更新工作树的一部分；如果工作树指向了一个新的分支，那么就会更新索引(index)和HEAD。</p>
<p><em>cherry-picking</em></p>
<blockquote>
<p>  In SCM jargon, “cherry pick” means to choose a subset of<br>    changes out of a series of changes (typically commits) and record them<br>    as a new series of changes on top of a different codebase. In GIT, this is<br>    performed by the “git cherry-pick” command to extract the change introduced<br>    by an existing commit and to record it based on the tip<br>    of the current branch as a new commit.</p>
</blockquote>
<p><em>cherry-picking</em></p>
<blockquote>
<p>  在SCM的行话里，“cherry pick“ 意味着从一系列的修改中选出一部分修改(通常是提交)，应用到当前代码中。()</p>
</blockquote>
<p><em>clean（干净）</em></p>
<blockquote>
<p>  如果一个工作树(working tree)中所有的修改都已提交到了当前分支里(current head)，那么就说它是干净的(clean)，反之它就是脏的(dirty)。</p>
</blockquote>
<p><em>commit</em></p>
<blockquote>
<p>  As a verb: The action of storing a new snapshot of the project’s<br>    state in the git history, by creating a new commit representing the current<br>    state of the index and advancing HEAD<br>    to point at the new commit.</p>
</blockquote>
<p><em>commit（提交）</em></p>
<blockquote>
<p>  作为名词：指向git历史的某一点的指针；整个项目的历史就由一组相互关联的提交组成的。提交(commit)在其它版本控制系统中也做”revision”或”version”。同时做为提交对象(commit object)的缩写。</p>
<p>  作为动词：创建一新的提交(commit)来表示当前索引(index)的状态的行为，把 HEAD 指向新创建的提交，这一系列把项目在某一时间上的快照(snapshot)保存在git历史中的操作。</p>
</blockquote>
<p><em>提交对象</em></p>
<blockquote>
<p>  一个关于特定版本信息(particular revision)的对象。包括父对象名，提交者，作者，日期和存储了此版本内容的树对象名(tree object)。</p>
</blockquote>
<p><em>core git</em></p>
<blockquote>
<p>  Git的基本数据结构和工具，它只对外提供简单的代码管理工具。</p>
</blockquote>
<p><em>DAG</em></p>
<blockquote>
<p>  有向无环图。众多提交对象(commit objects)组成了一个有向无环图；因为它们都有直接父对象(direct parent)，且没有一条提交线路(chain)的起点和终点都是同一个对象。</p>
</blockquote>
<p><em>dangling object（悬空对象）</em></p>
<blockquote>
<p>  一个甚至从其它不可达对象也不可达的对象(unreachable object)；仓库里的一个悬空对象没有任何引用(reference)或是对象(object)引用它。</p>
</blockquote>
<p><em>detached HEAD（分离的HEAD）</em></p>
<blockquote>
<p>  通常情况下HEAD里是存放当前分支的名字。然而 git 有时也允许你签出任意的一个提交(commit)，而不一定是某分支的最近的提交(the tip of any particular branch)；在这种情况下，HEAD就是处于分离的状态(detached)。<br>  译者注：这时<code>.git/HEAD</code>中存储的就是签出的提交的SHA串值。</p>
</blockquote>
<p><em>dircache</em></p>
<blockquote>
<p>  请参见索引(index)。</p>
</blockquote>
<p><em>directory（目录）</em></p>
<blockquote>
<p>  执行”ls”命令所显示的结果 :-)</p>
</blockquote>
<p><em>dirty（脏）</em></p>
<blockquote>
<p> 一个工作树里有没有提交到当前分支里修改，那么我就说它是脏的(dirty)。</p>
</blockquote>
<p><em>ent</em></p>
<blockquote>
<p>  某些人给树名(tree-ish)起的另外一个别名，这里<code>http://en.wikipedia.org/wiki/Ent_(Middle-earth)</code>有更详细的解释。最好不要使用这个名词，以免让大家糊涂。</p>
</blockquote>
<p><em>evil merge（坏的合并）</em></p>
<blockquote>
<p>  如果一次合并引入一些不存在于任何父对象(parent)中的修改，那么就称它是一个坏的合并(evil merge)。</p>
</blockquote>
<p><em>fast forward</em></p>
<blockquote>
<p>  A fast-forward is a special type of merge where you have a<br>    revision and you are “merging” another<br>    branch’s changes that happen to be a descendant of what<br>    you have. In such these cases, you do not make a new merge<br>    commit but instead just update to his<br>    revision. This will happen frequently on a<br>    tracking branch of a remote<br>    repository.</p>
</blockquote>
<p><em>快速向前</em></p>
<blockquote>
<p>  “fast-forward”是一种特殊的合并,()。<br>  在这种情况下，并没有创建一个合并提交(merge commit)，只是更新了版本信息。<br>  当本地分支是远端仓库(remote repository)的跟踪分支时，这种情况经常出现。</p>
</blockquote>
<p><em>fetch（抓取）</em></p>
<blockquote>
<p>  抓取一个分支意味着：得到远端仓库(remote repository)分支的head ref，找出本地对象数据库所缺少的对象，并把它们下载下来。你可以参考一下 linkgit:git-fetch[1]。</p>
</blockquote>
<p><em>file system（文件系统）</em></p>
<blockquote>
<p>  Linus Torvalds 最初设计 git 时，是把它设计成一个在用户空间(user space)运行的文件系统；也就是一个用来保存文件和目录的 infrastructure，这样就保证了git的速度和效率。</p>
</blockquote>
<p><em>git archive</em></p>
<blockquote>
<p>  对玩架构的人来说，这就是仓库的同义词。</p>
</blockquote>
<p><em>grafts</em></p>
<blockquote>
<p>  Grafts enables two otherwise different lines of development to be joined<br>    together by recording fake ancestry information for commits. This way<br>    you can make git pretend the set of parents a commit has<br>    is different from what was recorded when the commit was<br>    created. Configured via the <code>.git/info/grafts</code> file.</p>
</blockquote>
<p><em>hash（哈希）</em></p>
<blockquote>
<p>  在git里，这就是对象名(object name)的同义词。</p>
</blockquote>
<p><em>head</em></p>
<blockquote>
<p>  指向一个分支最新提交的命名引用(named reference)。除非使用了打包引用(packed refs)，heads 一般存储在 <code>$GIT_DIR/refs/heads/</code>。    参见: linkgit:git-pack-refs[1]</p>
</blockquote>
<p><em>HEAD</em></p>
<blockquote>
<p>  当前分支。详细的讲是：你的工作树(working tree)通是从HEAD所指向的tree所派生的来的。<br>  HEAD 必须是指向一个你仓库里的head，除非你使用分离的HEAD(detached HEAD)。</p>
</blockquote>
<p><em>head ref</em></p>
<blockquote>
<p>  head的同义词。</p>
</blockquote>
<p><em>hook</em></p>
<blockquote>
<p>  During the normal execution of several git commands, call-outs are made<br>    to optional scripts that allow a developer to add functionality or<br>    checking. Typically, the hooks allow for a command to be pre-verified<br>    and potentially aborted, and allow for a post-notification after the<br>    operation is done. The hook scripts are found in the<br>    <code>$GIT_DIR/hooks/</code> directory, and are enabled by simply<br>    removing the <code>.sample</code> suffix from the filename. In earlier versions<br>    of git you had to make them executable.</p>
</blockquote>
<p><em>钩子</em></p>
<blockquote>
<p>  在一些git命令的执行过程中, () 允许开发人员调用特别的脚本来添加功能或检查。<br>    ()</p>
</blockquote>
<pre><code>Typically，钩子允许对一个命令做pre-verified并且可以中止此命令的运行；同时也可在这个命令执行完后做后继的通知工作。这些钩子脚本放在`<span class="variable">$GIT</span>_DIR/hooks/`目录下，你只要把这它们文件名的`.sample`后缀删掉就可以了。不过在git的早期版本，你需要为这些钩子脚本加上可执行属性。
</code></pre><p><em>index</em></p>
<blockquote>
<p>  A collection of files with stat information, whose contents are stored<br>    as objects. The index is a stored version of your<br>    working tree. Truth be told, it can also contain a second, and even<br>    a third version of a working tree, which are used<br>    when merging.</p>
</blockquote>
<p><em>索引</em></p>
<blockquote>
<p>  描述项目状态信息的文件，。索引里保存的是你的工作树的版本记录。()</p>
</blockquote>
<p><em>index entry</em></p>
<blockquote>
<p>  The information regarding a particular file, stored in the<br>    index. An index entry can be unmerged, if a<br>    merge was started, but not yet finished (i.e. if<br>    the index contains multiple versions of that file).</p>
</blockquote>
<p><em>索引条目</em></p>
<blockquote>
</blockquote>
<p><em>主分支 (master)</em></p>
<blockquote>
<p>  默认的开发分支。当你创建了一个git仓库，一个叫”master”的分支就被创建并且成为当前活动分支(active branch)。在多数情况下，这个分支里就包含有本地的开发内容。</p>
</blockquote>
<p><em>merge</em></p>
<blockquote>
<p>  As a verb: To bring the contents of another<br>    branch (possibly from an external<br>    repository) into the current branch.  In the<br>    case where the merged-in branch is from a different repository,<br>    this is done by first fetching the remote branch<br>    and then merging the result into the current branch.  This<br>    combination of fetch and merge operations is called a<br>    pull.  Merging is performed by an automatic process<br>    that identifies changes made since the branches diverged, and<br>    then applies all those changes together.  In cases where changes<br>    conflict, manual intervention may be required to complete the<br>    merge.</p>
</blockquote>
<p><em>merge（合并）</em></p>
<blockquote>
<p>  作为动词：把另外一个分支(也许来自另外一个仓库)的内容合并进当前的分支。()</p>
<p>  作为名词：除非合并的结果是 fast forward；那么一次成功的合并会创建一个新的提交(commit)来表示这次合并，并且把合并了的分支做为此提交(commit)的父对象。这个提交(commit)也可以表述为“合并提交”(merge commit)，或者就是”合并”(merge 名词)。</p>
</blockquote>
<p><em>object（对象）</em></p>
<blockquote>
<p>  Git的存储单位，它以对象内容的SHA1值做为唯一对象名；因此对象内容是不能被修改的。</p>
</blockquote>
<p><em>object database（对象仓库）</em></p>
<blockquote>
<p>  用来存储一组对象(objects)，每个对象通过对象名来区别。对象(objects)通常保存在 <code>$GIT_DIR/objects/</code>。</p>
</blockquote>
<p><em>object identifier（对象标识符）</em></p>
<blockquote>
<p>  对象名(object name)的同义词。</p>
</blockquote>
<p><em>object name（对象名）</em></p>
<blockquote>
<p>  一个对象的唯一标识符(unique identifier)。它是使用SHA1算法(Secure Hash Algorithm 1)给对象内容进行哈希(hash)计算，产生的一个40个字节长的16进制编码的串。</p>
</blockquote>
<p><em>object type（对象类型）</em></p>
<blockquote>
<p>  Git有4种对象类型：提交(commit)，树(tree)，标签(tag)和二进制块(blob)。</p>
</blockquote>
<p><em>octopus（章鱼）</em></p>
<blockquote>
<p>  一次多于两个分支的合并(merge)。也用来表示聪明的肉食动物。</p>
</blockquote>
<p><em>origin</em></p>
<blockquote>
<p>  默认的上游仓库(upstream repository)。每个项目至少有一个它追踪(track)的上游(upstream)仓库，通常情况 origin 就是用来表示它。你可以用 ”｀git branch -r`“ 命令查看上游仓库(upstream repository)里所有的分支，再用 origin/name-of-upstream-branch 的名字来抓取(fetch)远程追踪分支里的内容。</p>
</blockquote>
<p><em>pack（包）</em></p>
<blockquote>
<p>  一个文件，里面有一些压缩了的对象。(用以节约空间或是提高传输效率)。</p>
</blockquote>
<p><em>pack index（包索引）</em></p>
<blockquote>
<p>  包(pack)里的一些标识符和其它相关信息，用于帮助git快速的访问包(pack)里面的对象。</p>
</blockquote>
<p><em>parent</em></p>
<blockquote>
<p>  A commit object contains a (possibly empty) list<br>    of the logical predecessor(s) in the line of development, i.e. its<br>    parents.</p>
</blockquote>
<p><em>父对象</em></p>
<blockquote>
<p>  一个提交对象(commit object)，()。</p>
</blockquote>
<p><em>pickaxe</em></p>
<blockquote>
<p>  The term pickaxe refers to an option to the diffcore<br>    routines that help select changes that add or delete a given text<br>    string. With the <code>--pickaxe-all</code> option, it can be used to view the full<br>    changeset that introduced or removed, say, a<br>    particular line of text. See linkgit:git-diff[1].</p>
</blockquote>
<p><em>plumbing</em><br>&gt;</p>
<blockquote>
<p>  core git的别名(cute name)。</p>
</blockquote>
<p><em>porcelain</em></p>
<blockquote>
<p>  Cute name for programs and program suites depending on<br>    core git, presenting a high level access to<br>    core git. Porcelains expose more of a SCM<br>    interface than the plumbing.</p>
</blockquote>
<p><em>pull（拉）</em></p>
<blockquote>
<p>  拉(pull)一个分支意味着，把它抓取(fetch)下来并合并(merge)进当前的分支。可以参考 linkgit:git-pull[1].</p>
</blockquote>
<p><em>push</em></p>
<blockquote>
<p>  Pushing a branch means to get the branch’s<br>    head ref from a remote repository,<br>    find out if it is a direct ancestor to the branch’s local<br>    head ref, and in that case, putting all<br>    objects, which are reachable from the local<br>    head ref, and which are missing from the remote<br>    repository, into the remote<br>    object database, and updating the remote<br>    head ref. If the remote head is not an<br>    ancestor to the local head, the push fails.</p>
</blockquote>
<p><em>推</em></p>
<blockquote>
<p>  ()</p>
</blockquote>
<p><em>reachable</em></p>
<blockquote>
<p>  All of the ancestors of a given commit are said to be<br>    “reachable” from that commit. More<br>    generally, one object is reachable from<br>    another if we can reach the one from the other by a chain<br>    that follows tags to whatever they tag,<br>    commits to their parents or trees, and<br>    trees to the trees or blobs<br>    that they contain.</p>
<p><em>可达的</em></p>
</blockquote>
<p><em>rebase</em></p>
<blockquote>
<p>  重新应用(reapply)当前点(branch)和另一个点(base)间的修改；并且根据rebase的结果重置当前分支的 head。<br>  译者注：这个功能可以修改历史提交。</p>
</blockquote>
<p><em>ref（引用）</em></p>
<blockquote>
<p>  一个40字节长的SHA1串或是表示某个对象的名字。它们可能存储在 <code>$GIT_DIR/refs/</code>。</p>
</blockquote>
<p><em>reflog</em></p>
<blockquote>
<p>  reflog用以表示本地的ref的历史记录。从另外一角度也可以说，它能行告诉你这个仓库最近的第3个版本(revision)是什么，还可以告诉你昨天晚上9点14分时你是在这个仓库的哪个分支下工作。可以参见:linkgit:git-reflog[1]。</p>
</blockquote>
<p><em>refspec</em></p>
<blockquote>
<p>  “refspec”用于描述在抓取和推的过程中，远程ref和本地ref之间的映射关系。它用冒号连接：<src>:<dst>，前面也可以加一个加号：“+“。<br>  例如：<code>git fetch $URL refs/heads/master:refs/heads/origin</code> 意味着：从$URL抓取主分支的 head 并把它保存到本地的origin分支的head中。<code>git push $URL refs/heads/master:refs/heads/to-upstream</code> 意味着：把我本地主分支 head 推到$URL上的 to-upstream分支里。具体可以参见： linkgit:git-push[1]。</dst></src></p>
</blockquote>
<p><em>repository</em></p>
<blockquote>
<p>  A collection of refs together with an<br>    object database containing all objects<br>    which are reachable from the refs, possibly<br>    accompanied by meta data from one or more porcelains. A<br>    repository can share an object database with other repositories<br>    via alternates mechanism.</p>
</blockquote>
<p><em>resolve</em></p>
<blockquote>
<p>  在自动合并失败后，手工修复合并冲突的行为。</p>
</blockquote>
<p><em>revision（版本）</em></p>
<blockquote>
<p>  对象仓库(object database)保存的文件和目录在某一特定时间点的状态；它会被一个提交对象(commit object)所引用。</p>
</blockquote>
<p><em>rewind</em></p>
<blockquote>
<p>  丢弃某一部分开发成果。例如：把head 指向早期的版本。</p>
</blockquote>
<p><em>SCM</em></p>
<blockquote>
<p>  源代码管理工作。</p>
</blockquote>
<p><em>SHA1</em></p>
<blockquote>
<p>  对象名(object name)的同义词。</p>
</blockquote>
<p><em>shallow repository</em></p>
<blockquote>
<p>  A shallow repository has an incomplete<br>    history some of whose commits have parents cauterized away (in other<br>    words, git is told to pretend that these commits do not have the<br>    parents, even though they are recorded in the commit<br>    object). This is sometimes useful when you are interested only in the<br>    recent history of a project even though the real history recorded in the<br>    upstream is much larger. A shallow repository<br>    is created by giving the <code>--depth</code> option to linkgit:git-clone[1], and<br>    its history can be later deepened with linkgit:git-fetch[1].</p>
</blockquote>
<p><em>symref</em></p>
<blockquote>
<p>  Symbolic reference: instead of containing the SHA1<br>    id itself, it is of the format ‘ref: refs/some/thing’ and when<br>    referenced, it recursively dereferences to this reference.<br>    ‘HEAD’ is a prime example of a symref. Symbolic<br>    references are manipulated with the linkgit:git-symbolic-ref[1]<br>    command.</p>
</blockquote>
<p><em>tag（标签）</em></p>
<blockquote>
<p>  一个ref指向一个标签或提交对象。与 head 相反，标签并不会在一次提交操作后改变。标签(不是标签对象)存储在<code>$GIT_DIR/refs/tags/</code>。 一个标签通常是用来标识提交家族链(commit ancerstry chain)里的某一点。</p>
</blockquote>
<p><em>tag object（标签对象）</em></p>
<blockquote>
<p>  一个含有指向其它对象的引用(ref)的对象，对象里包括注释消息。如果它里面可以含有一个PGP签名，那么就称为一个“签名标签对象”(signed tag object)。</p>
</blockquote>
<p><em>topic branch</em></p>
<blockquote>
<p>  A regular git branch that is used by a developer to<br>    identify a conceptual line of development. Since branches are very easy<br>    and inexpensive, it is often desirable to have several small branches<br>    that each contain very well defined concepts or small incremental yet<br>    related changes.</p>
</blockquote>
<p><em>tracking branch</em></p>
<blockquote>
<p>  A regular git branch that is used to follow changes from<br>    another repository. A tracking<br>    branch should not contain direct modifications or have local commits<br>    made to it. A tracking branch can usually be<br>    identified as the right-hand-side ref in a Pull:</p>
</blockquote>
<pre><code>refspec.
</code></pre><p><em>追踪分支</em></p>
<blockquote>
<p>  一个用以追踪(follow)另外一个仓库的修改的git分支。()</p>
</blockquote>
<p><em>tree（树）</em></p>
<blockquote>
<p>  可以是一个工作树(working tree)，也可以是一个树对象(tree object)。</p>
</blockquote>
<p><em>tree object（树对象）</em></p>
<blockquote>
<p>  包含有一串(list)文件名和模式(mode)，并且指向与之相关的二进制对象(blob object)和树对象(tree object)。一个树(tree)等价于一个目录。</p>
</blockquote>
<p><em>tree-ish（树名）</em></p>
<blockquote>
<p>  一个指向的提交对象(commit object)，树对象(tree object)或是标签对象(tag object)的引用(ref)。</p>
</blockquote>
<p><em>unmerged index（未合并索引）</em></p>
<blockquote>
<p>  一个索引中包含有未合并的索引条目(index entries)。</p>
</blockquote>
<p><em>unreachable object（不可达对象）</em></p>
<blockquote>
<p>  从任何一个分支、标签或是其它引用(reference)做为起点都无法到达的一个对象。</p>
</blockquote>
<p><em>working tree（工作树）</em></p>
<blockquote>
<p>  签出(checkout)用于编辑的文件目录树。 工作树一般等价于 HEAD 加本地没有提交的修改。</p>
</blockquote>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
			
		
	
	
		<li class="prev"><a href="/2015/10/7_7/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next disabled"><a>next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
<<<<<<< HEAD
	欢迎关注<strong>Git小助手</strong>，微信号：git-repo <img src="https://github.com/huangfude/source/blob/master/images/gitrepo.jpg?raw=true" />
=======
  &copy; 2015 http://gitbook.liuhui998.com
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
>>>>>>> b3482d662731bcd8b034f064a94793b0e4183171
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
